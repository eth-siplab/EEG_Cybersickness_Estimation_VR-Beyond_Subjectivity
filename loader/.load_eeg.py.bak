import pathlib
import torchdatasets as td
import pandas as pd
import torch
import matplotlib.pyplot as plt
from scipy.signal import spectrogram
from scipy.fft import fft
from scipy.signal import resample
import numpy as np
import os

# Desired columns for the EEG files
desired_columns = [
    # "Millis",
    "Fp1",
    "Fp2",
    "F3",
    "F4",
    "T3",
    "T4",
    "P3",
    "P4",
]


class EEGDataset(td.Dataset):
    def __init__(
        self,
        root: str,
        patient: int,
        position: str,
        window_size: int = 1,
        fs: int = 300,
    ):
        super().__init__()

        fname = (
            pathlib.Path(root) / f"{patient:04d}" / f"{patient:04d}_{position}_EEG.csv"
        )
        joystick_fname = (
            pathlib.Path(root)
            / f"{patient:04d}"
            / f"{patient:04d}_{position}_SubjectiveCs.csv"
        )

        assert os.path.isfile(fname), f"{fname} is not a file"

        eeg_timestamp = pd.read_csv(fname)["Millis"]
        joy_timestamp = pd.read_csv(joystick_fname)["Millis"]
        min_time = max(eeg_timestamp.min(), joy_timestamp.min())
        max_time = min(eeg_timestamp.max(), joy_timestamp.max())
        ranges = range(min_time, max_time, 1000 * window_size)

        eeg_segments = preprocess_eeg(
            fname,
            min_timestamp=min_time,
            max_timestamp=max_time,
            window_size=window_size,
            fs=fs,
        )
        joystick_segments = preprocess_joystick(
            joystick_fname,
            fs=fs,
            window_size=window_size,
            min_timestamp=min_time,
            max_timestamp=max_time,
        )
        f, t, Sxx = eeg_spectrogram = spectrogram(
            eeg_segments, fs=fs, nperseg=127, noverlap=124
        )
        self.eeg_spectogram = Sxx
        self.num_channels = 8
        self.num_freq_bins = 64
        self.num_time_frames = 53
        assert self.eeg_spectogram.shape[1] == self.num_channels
        assert self.eeg_spectogram.shape[2] == self.num_freq_bins
        cache_filename = f"{patient:04d}_{position}_EEG"
        cache = "/tmp/torch-runner/data-cache/juliette-eeg-dataset/" + cache_filename
        # pdb.set_trace()
        self.cache(td.cachers.Tensor(pathlib.Path(cache)))

    def __getitem__(self, index):
        eeg = torch.from_numpy(self.eeg_spectogram[index])
        return eeg[:, :, : self.num_time_frames].float()

    def __len__(self):
        return len(self.eeg_spectogram)


# Directory to save the .npz cache files
cache_dir = "/tmp/torch-runner/data-cache"
os.makedirs(cache_dir, exist_ok=True)


# Function to preprocess EEG data
def preprocess_eeg(
    fname: pathlib.Path,
    min_timestamp: int,
    max_timestamp: int,
    window_size: int = 1,
    fs: int = 300,
):
    """
    Splits EEG data into fixed-size windows.

    Parameters:
    - data: A 2D numpy array (channels x time).
    - window_size: The size of each segment in seconds.
    - fs: The sampling frequency (in Hz).

    Returns:
    - segments: A 3D numpy array (n_segments x channels x window_length).
    """
    # Rename columns
    df = pd.read_csv(fname)
    index = (min_timestamp <= df["Millis"]) & (df["Millis"] <= max_timestamp)
    desired_df = df[index][desired_columns].copy()

    # Normalize each channel (excluding 'Millis' and 'Hardware')
    desired_df = (desired_df - desired_df.mean()) / (desired_df.std() + 1e-5)

    desired_df["Window"] = (df[index]["Millis"] - min_timestamp) // (1000 * window_size)

    desired_arrays = [
        resample(DF.drop("Window", axis=1).to_numpy(), num=fs).transpose()
        for _, DF in desired_df.groupby("Window")
    ]

    return np.stack(desired_arrays)


def preprocess_joystick(
    fname: pathlib.Path, window_size, fs, min_timestamp: int, max_timestamp: int
):
    df = pd.read_csv(fname)
    index = (min_timestamp <= df["Millis"]) & (df["Millis"] <= max_timestamp)
    desired_df = df[index][["Rating"]].copy()
    desired_df["Window"] = (df[index]["Millis"] - min_timestamp) // (1000 * window_size)

    desired_arrays = []

    ff = set(range((max_timestamp - min_timestamp) // (1000 * window_size)))
    for idx in sorted(ff.difference(set(desired_df["Window"]))):
        last_row = desired_df[desired_df["Window"] == idx - 1].iloc[-1:]
        last_row["Window"] = idx
        desired_df = pd.concat([desired_df, last_row], ignore_index=True)

    for window_idx, DF in desired_df.sort_values(by="Window", kind="stable").groupby(
        "Window"
    ):
        desired_arrays.append(
            resample(DF.drop("Window", axis=1).to_numpy(), num=fs).transpose()
        )
        # print(window_idx)

    return np.stack(desired_arrays)


if __name__ == "__main__":
    # Example usage:
    # Assuming `eeg_data` is a 2D numpy array of shape (channels, time) and fs is 250Hz
    # eeg_data = np.random.randn(8, 3450)  # Example EEG data (replace with actual data)
    window_size = 1  # Window size in seconds
    fs = 300  # Sampling frequency in Hz
    fname = "/home/adhd/src/research/human-computer-interaction/eeg/StudyExport/0003/0003_FR_EEG.csv"
    ds = EEGDataset(
        "/home/adhd/src/research/human-computer-interaction/eeg/StudyExport/", 3, "FR"
    )

    eeg_data = preprocess_eeg(fname)
    eeg_segments = segment_eeg(eeg_data, window_size, fs)
    f, t, Sxx = eeg_spectrogram = spectrogram(
        eeg_segments, fs=fs, nperseg=127, noverlap=124
    )

    fix, axes = plt.subplots(2, 4, figsize=(12, 48))
    for i in range(8):
        idx = i // 4, i % 4
        pcm = axes[idx].pcolormesh(t, f, Sxx[0, i], shading="gouraud")

        axes[idx].set_title(desired_columns[i])
        axes[idx].set_ylabel("Frequency [Hz]")
        axes[idx].set_xlabel("Time [sec")

        # Add the colorbar to the current axis
        plt.colorbar(pcm, ax=axes[idx])
    # plt.tight_layout()
    plt.show()

    """
    reshaped_eeg_data = eeg_segments.transpose(1,2,0)

    for segment_idx in range(reshaped_eeg_data.shape[1]):
        segment_data = reshaped_eeg_data[:, segment_idx, :]

        fft_result = np.abs(fft(segment_data, n=53, axis=-1))
    """
